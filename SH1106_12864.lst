C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SH1106_12864
OBJECT MODULE PLACED IN .\hex\SH1106_12864.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE Source\SH1106_12864.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\SH1106_12864.lst) TABS(2) OBJECT(.\hex\SH1106_12864.obj)

line level    source

   1          
   2          #include "main.h"
   3          //#include"SH1106_12864.h"
   4          #include "ASCII_CODE_8X16_5X8_VERTICAL.H"
   5          //#include "chinese_and_graphic.h"
   6          //#include "font.h"
   7           
   8          /*
   9            @brief      延迟1us
  10            @param      无
  11            @retval     无
  12           */
  13          void Delay1us(unsigned char num)
  14          {
  15   1      
  16   1        while(num--)
  17   1        {
  18   2          _nop_();
  19   2          _nop_();
  20   2          _nop_();
  21   2        }
  22   1      
  23   1      }
  24          
  25          //延时
  26          void delay(int i)               
  27          {
  28   1        unsigned char k;
  29   1        int j;
  30   1        for(j=0;j<i;j++)
  31   1          for(k=0;k<110;k++);
  32   1      }
  33          
  34          #ifdef SPI
              //写指令到OLED显示模块
              void transfer_command(int data1)   
              {
                  uchar i;
                  lcd_dc= 0;    
                for(i=0;i<8;i++)
                {
                      lcd_sclk = 0;    
                      if (data1 & 0x80) lcd_sda = 1;
                      else          lcd_sda = 0;
                      lcd_sclk = 1; 
                      data1 <<= 1;    
                  }
              }
              
              //写数据到OLED显示模块
              void transfer_data(int data1)
              {
                  uchar i;
                  lcd_dc= 1;    
C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 2   

                for(i=0;i<8;i++)
                {
                      lcd_sclk = 0;    
                      if (data1 & 0x80) lcd_sda = 1;
                      else          lcd_sda = 0;
                      lcd_sclk = 1; 
                      data1 <<= 1;    
                  }
              } 
              #else
  65          
  66          void start()
  67          {
  68   1           SCL=1;  Delay1us(1);
  69   1           SDA=1;  Delay1us(1);
  70   1           SDA=0;  Delay1us(1);
  71   1           SCL=0;  Delay1us(1);
  72   1      }
  73          
  74          void stop()
  75          {
  76   1           SCL=0;  Delay1us(1);
  77   1           SDA=0;  Delay1us(1);
  78   1           SDA=1;  Delay1us(1);
  79   1           SCL=1;  Delay1us(1);
  80   1      }
  81          
  82          void write_w(unsigned char dat)
  83          {
  84   1           unsigned char m,da;
  85   1           unsigned char j;
  86   1           da=dat;
  87   1           for(j=0;j<8;j++)
  88   1           {
  89   2             m=da;
  90   2             SCL=0;  Delay1us(1);
  91   2             m=m&0x80;
  92   2             if(m==0x80)
  93   2           {
  94   3              SDA=1; Delay1us(1);
  95   3           }
  96   2             else
  97   2           {
  98   3              SDA=0;  Delay1us(1);
  99   3           }
 100   2             da=da<<1;Delay1us(1);
 101   2             SCL=1;  Delay1us(1);
 102   2         }
 103   1           SCL=0;   Delay1us(1);
 104   1           //_nop_();  
 105   1           SCL=1;   Delay1us(1);
 106   1      }
 107           
 108          //写指令到OLED显示模块
 109          void transfer_command(int data1)   
 110          {
 111   1           start();
 112   1           write_w(0x78);
 113   1           write_w(0x00);
 114   1           write_w(data1);
 115   1           stop();
 116   1      }
C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 3   

 117          
 118          //写数据到OLED显示模块
 119          void transfer_data(int data1)
 120          {
 121   1           start();
 122   1           write_w(0x78);
 123   1           write_w(0x40);
 124   1           write_w(data1);
 125   1           stop();
 126   1      }
 127          
 128          
 129          #endif   
 130          
 131                      //y     x
 132          void lcd_address(uchar page,uchar column)
 133          {
 134   1        column=column;                //我们平常所说的第1列，在LCD驱动IC里是第0列。所以在这里减去1.
 135   1        page=page-1;
 136   1        transfer_command(0xb0+page);        //设置页地址。每页是8行。一个画面的64行被分成8个页。我们平常所说的第1页
             -，在LCD驱动IC里是第0页，所以在这里减去1
 137   1        transfer_command(((column>>4)&0x0f)+0x10);  //设置列地址的高4位
 138   1        transfer_command(column&0x0f);        //设置列地址的低4位
 139   1      }
 140            
 141          //全屏清屏
 142          void clear_screen()
 143          {
 144   1        unsigned char i,j;
 145   1        for(j=0;j<8;j++)
 146   1        {
 147   2          lcd_address(1+j,0);
 148   2          for(i=0;i<128;i++)
 149   2          {
 150   3            transfer_data(0x00);
 151   3          }
 152   2        }
 153   1      }
 154          
 155          //OLED显示模块初始化
 156          void initial_lcd()
 157          {
 158   1        
 159   1               
 160   1        delay(500);//这里的延时很重要,一般50ms即可,保险起见，可以长一些
 161   1       
 162   1        transfer_command(0xAE); //关闭显示
 163   1      
 164   1        transfer_command(0x00); //设置低列地址
 165   1        transfer_command(0x10); //设置高列地址
 166   1        transfer_command(0x40); //设置起始行地址
 167   1        transfer_command(0xB0); //设置页地址
 168   1      
 169   1        transfer_command(0x81);   // 对比度设置，可设置亮度
 170   1        transfer_command(0xFF); //  265  
 171   1      
 172   1        transfer_command(0xA1); //设置段（SEG）的起始映射地址；column的127地址是SEG0的地址
 173   1        transfer_command(0xA6); //正常显示；0xa7逆显示
 174   1      
 175   1        transfer_command(0xA8); //设置驱动路数（16~64）
 176   1        transfer_command(0x3F); //64duty
 177   1        
C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 4   

 178   1        transfer_command(0xC8); //重映射模式，COM[N-1]~COM0扫描
 179   1      
 180   1        transfer_command(0xD3); //设置显示偏移
 181   1        transfer_command(0x00); //无偏移
 182   1        
 183   1        transfer_command(0xD5); //设置震荡器分频
 184   1        transfer_command(0x80); //使用默认值
 185   1        
 186   1        transfer_command(0xD9); //设置 Pre-Charge Period
 187   1        transfer_command(0xF1); //使用官方推荐值
 188   1        
 189   1        transfer_command(0xDA); //设置 com pin configuartion
 190   1        transfer_command(0x12); //使用默认值
 191   1        
 192   1        transfer_command(0xDB); //设置 Vcomh，可调节亮度（默认）
 193   1        transfer_command(0x40); ////使用官方推荐值
 194   1        
 195   1        transfer_command(0x8D); //设置OLED电荷泵
 196   1        transfer_command(0x14); //开显示
 197   1        
 198   1        transfer_command(0xAF); //开启OLED面板显示
 199   1        clear_screen();  //初始清屏
 200   1        lcd_address(0,0); 
 201   1      }
 202            
 203          //显示8x16的点阵的字符串，括号里的参数分别为（页,列，字符串指针）
 204          void display_string_8x16(uint page,uint column,uchar *text)
 205          {
 206   1        uint i=0,j,k,n;
 207   1        if(column>123)
 208   1        {
 209   2          column=1;
 210   2          page+=2;
 211   2        }
 212   1        while(text[i]>0x00)
 213   1        { 
 214   2          if((text[i]>=0x20)&&(text[i]<=0x7e))
 215   2          {
 216   3            j=text[i]-0x20;
 217   3            for(n=0;n<2;n++)
 218   3            {     
 219   4              lcd_address(page+n,column);
 220   4              for(k=0;k<8;k++)
 221   4              {         
 222   5                transfer_data(ascii_table_8x16[j][k+8*n]);  //写数据到LCD,每写完1字节的数据后列地址自动加1
 223   5              }
 224   4            }
 225   3            i++;
 226   3            column+=8;
 227   3          }
 228   2          else
 229   2          i++;
 230   2        }
 231   1      }
 232          
 233          //写入一组16x16点阵的汉字字符串（字符串表格中需含有此字）
 234          //括号里的参数：(页，列，汉字字符串）
 235          void display_string_16x16(uchar page,uchar column,uchar *text)
 236          {
 237   1          uchar i,j,k;
 238   1          uint address; 
 239   1          
C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 5   

 240   1          j = 0;
 241   1          while(text[j] != '\0')
 242   1          {
 243   2              i = 0;
 244   2              address = 1;
 245   2              while(Chinese_text_16x16[i] > 0x7e)   // >0x7f即说明不是ASCII码字符
 246   2              {
 247   3                  if(Chinese_text_16x16[i] == text[j])
 248   3                  {
 249   4                      if(Chinese_text_16x16[i + 1] == text[j + 1])
 250   4                      {
 251   5                          address = i * 16;
 252   5                          break;
 253   5                      }
 254   4                  }
 255   3                  i += 2;            
 256   3              }
 257   2              
 258   2              if(column > 113)
 259   2              {
 260   3                  column = 0;
 261   3                  page += 2;
 262   3              }
 263   2              
 264   2              if(address != 1)// 显示汉字                   
 265   2              {
 266   3                  
 267   3            for(k=0;k<2;k++)
 268   3            {
 269   4              lcd_address(page+k,column);
 270   4                    for(i = 0; i < 16; i++)               
 271   4                    {
 272   5                        transfer_data(Chinese_code_16x16[address]);   
 273   5                        address++;
 274   5                    }
 275   4              }
 276   3                  j += 2;        
 277   3              }
 278   2              else              //显示空白字符            
 279   2              {
 280   3            for(k=0;k<2;k++)
 281   3            {
 282   4              lcd_address(page+k,column);
 283   4                    for(i = 0; i < 16; i++)               
 284   4                    {
 285   5                        transfer_data(0x00);   
 286   5                    }
 287   4              }
 288   3                  
 289   3                  j++;
 290   3              }
 291   2              
 292   2              column+=16;
 293   2          }
 294   1      }
 295           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1206    ----
   CONSTANT SIZE    =    739    ----
   XDATA SIZE       =   ----      25
C51 COMPILER V9.60.0.0   SH1106_12864                                                      12/27/2023 11:38:56 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
