C51 COMPILER V9.60.0.0   KEY                                                               12/27/2023 11:38:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\hex\key.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE Source\key.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -key.lst) TABS(2) OBJECT(.\hex\key.obj)

line level    source

   1          //==============================================================================
   2          //  Include Header Files
   3          //==============================================================================
   4          #include "main.h"
   5          
   6          bit Key_Scan_Cnt; // 定时器变量10ms执行一次
   7          KeyValue_ENUM key;
   8          // 按键扫描
   9          KeyValue_ENUM KeyScan(void)
  10          {
  11   1        uint8_t io_value;
  12   1        static uint8_t key_Press; // 这个是要返回的键值
  13   1        static uint8_t key_Old = 0x00;
  14   1        static uint8_t DownCnt = 0; // 按下计数
  15   1        static uint8_t CntLongPress = 0;
  16   1        static struct _sta
  17   1        {
  18   1          uint8_t up : 1; // 弹起
  19   1          uint8_t dn : 1; // 按下
  20   1          uint8_t rep : 1;
  21   1        } Status; // 按键状态标记
  22   1        uint8_t ret;
  23   1      
  24   1        io_value = 0x00;
  25   1        ret = KEY_OFF;
  26   1      
  27   1        // 获取当前按下的按键
  28   1        if (!KEY_SW)
  29   1          io_value |= KEY_S1;
  30   1        if (!KEY_Up)
  31   1          io_value |= KEY_S2;
  32   1        if (!KEY_Dowm)
  33   1          io_value |= KEY_S3;
  34   1      
  35   1        // if (!Key4_ReadSta())io_value |= KEY_S4;
  36   1      
  37   1        if (io_value) // 如果按键被按下
  38   1        {
  39   2          if (key_Old == io_value) // 判断与上次扫描到的是否为同一个按键
  40   2          {
  41   3            DownCnt++; // 计数
  42   3      
  43   3            if (DownCnt < KEY_DOWN_CNT) // 当前计数小于长按的时间
  44   3            {
  45   4              if (Status.rep == 0) // 不是重复
  46   4              {
  47   5                Status.dn = 1;
  48   5                key_Press = io_value; // 记下按键
  49   5              }
  50   4            }
  51   3      
  52   3            if (DownCnt >= KEY_DOWN_CNT) // 当前计数大于长按的时间
  53   3            {
  54   4              Status.rep = 1; // 标记重复
C51 COMPILER V9.60.0.0   KEY                                                               12/27/2023 11:38:57 PAGE 2   

  55   4      
  56   4              if (CntLongPress++ == KEY_REP_3S) // 按下超过3秒
  57   4              {
  58   5                ret = io_value | KEY_LONG_FLAG; // 加长按标记
  59   5              }
  60   4              else
  61   4              {
  62   5                ret = io_value | KEY_REP_FLAG; // 重复
  63   5              }
  64   4      
  65   4              DownCnt = KEY_SPEED_CNT; // 重复起始值
  66   4            }
  67   3          }
  68   2          key_Old = io_value; // 记录键值
  69   2        }
  70   1        else // 按键松开
  71   1        {
  72   2          if (Status.dn && !Status.rep) // 返回松开前的键值
  73   2          {
  74   3            ret = key_Press;
  75   3          }
  76   2      
  77   2          // 清除标记
  78   2          Status.dn = 0;
  79   2          Status.rep = 0;
  80   2          DownCnt = 0;
  81   2          CntLongPress = 0;
  82   2          key_Old = KEY_NO;
  83   2        }
  84   1      
  85   1        return (KeyValue_ENUM)ret; // 返回键值
  86   1      }
  87          //--------------END OF FILE---------------
  88          
  89          //==============================================================================
  90          //  Function: key_handle
  91          //    Input: None
  92          //    Output: None
  93          //==============================================================================
  94          void key_handle(void)
  95          {
  96   1        if (Key_Scan_Cnt == 0)
  97   1          return;
  98   1        Key_Scan_Cnt = 0;
  99   1      
 100   1        key = KeyScan(); // 获取按下的按键值
 101   1        switch (key)
 102   1        {
 103   2        case KEY_Switch: //
 104   2          if (SW_Flag == 1)
 105   2            SW_Flag = 0;
 106   2          else if (SW_Flag == 0)
 107   2            SW_Flag = 1;
 108   2          break;
 109   2        case KEY_UUp: //
 110   2          ntc.Set_T += 1;
 111   2          if (ntc.Set_T > 50)
 112   2          {
 113   3            ntc.Set_T = 50;
 114   3          }
 115   2          Write_Set_T(ntc.Set_T); // 写入EEP_ROM
 116   2          break;
C51 COMPILER V9.60.0.0   KEY                                                               12/27/2023 11:38:57 PAGE 3   

 117   2        case KEY_DDown: //
 118   2          ntc.Set_T -= 1;
 119   2          if (ntc.Set_T < 1)
 120   2          {
 121   3            ntc.Set_T = 1;
 122   3          }
 123   2          Write_Set_T(ntc.Set_T); // 写入EEP_ROM
 124   2          break;
 125   2        default:
 126   2          break;
 127   2        }
 128   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    369    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
